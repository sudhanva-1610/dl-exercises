# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dvozmUwXujmHBgHgmMycNsKaxP3eKvoB
"""

# MNIST Multicalss classification using CNN - LeNET, AlexNET and VGGNET

# Necessary imports
import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torchvision
from torchvision import datasets, transforms
from torchvision.transforms import ToTensor
from torch.utils.data import DataLoader

# Data and it's small analysis
train_data = datasets.MNIST(
    root = 'data',
    train = True,
    download = True,
    transform = ToTensor(),
    target_transform = None
)

test_data = datasets.MNIST(
    root = 'data',
    train = False,
    download = True,
    transform = ToTensor(),
    target_transform = None
)

len(train_data.data) # 60000
train = DataLoader(train_data, batch_size = 32, shuffle = True)
test = DataLoader(test_data, batch_size = 32, shuffle = True)
len(train)
# DataLoader provides an iterator to loop through the dataset efficiently, making it compatible with Pythonâ€™s for loops.

for img, lb in train:
    plt.imshow(img[0].squeeze(dim = 0), cmap = "gray")
    plt.title(lb[0])
    break

import torch.nn.functional as F

class CNN(nn.Module):
  def __init__(self):
    super().__init__()
    self.conv1 = nn.Conv2d(1, 32, kernel_size = 5)
    self.conv2 = nn.Conv2d(32, 32, kernel_size = 5)
    self.conv3 = nn.Conv2d(32, 64 ,kernel_size = 5)
    self.fc1 = nn.Linear(3*3*64, 256)
    self.fc2 = nn.Linear(256, 10)

  def forward(self, x):
        x = F.relu(self.conv1(x))
        x = F.relu(F.max_pool2d(self.conv2(x), 2))
        x = F.dropout(x, p=0.5, training=self.training)
        x = F.relu(F.max_pool2d(self.conv3(x),2))
        x = F.dropout(x, p=0.5, training=self.training)
        x = x.view(-1,3*3*64 )
        x = F.relu(self.fc1(x))
        x = F.dropout(x, training=self.training)
        x = self.fc2(x)
        return F.log_softmax(x, dim=1)

# Training and testing loops
model_0 = CNN()
def fit(model, train):
  optimizer = torch.optim.SGD(model_0.parameters(), lr = 0.01)
  loss_fn = nn.CrossEntropyLoss()
  epochs = 5
  model.train()
  for epoch in range(epochs):
      correct = 0
      for b, (x, y) in enumerate(train):
        optimizer.zero_grad()
        y_pred = model(x)
        loss = loss_fn(y_pred, y)
        loss.backward()
        optimizer.step()

        predicted = torch.max(y_pred.data, 1)[1]
        correct += (predicted == y).sum()
        #print(correct)
        if b % 50 == 0:
          print("Accuracy", float(correct*100) / float(32*(b+1)))

fit(model_0, train)

def evaluate(model):
  correct = 0
  for img, lb in test:
    y_pred = model(img)
    yp = torch.argmax(y_pred, dim = 1)
    correct += (yp==lb).sum()

  print("Accuracy ", float(correct)/(len(test)*32))

evaluate(model_0)

